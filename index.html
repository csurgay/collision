<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collision</title>
</head>
<body>
    <canvas id="collision" width="800" height="600" style="border:1px solid #000;"></canvas>
    <script>
    const canvas = document.getElementById('collision');
    const ctx = canvas.getContext('2d');
    const handleSize = 10;
    let dragging = false;
    let dragOffset = { x: 0, y: 0 };
    let resizing = false;
    let activeHandle = null;
    let rotating = false;
    let rotateStartAngle = 0;
    let rotateStartMouse = { x: 0, y: 0 };
    let activeRectIdx = null;

    function getHandles(r) {
        const hw = r.w / 2, hh = r.h / 2;
        const cx = r.x + hw, cy = r.y + hh;
        const corners = [
            { x: -hw, y: -hh },
            { x: hw, y: -hh },
            { x: -hw, y: hh },
            { x: hw, y: hh }
        ].map(pt => rotatePoint(pt, r.angle));
        corners.forEach(pt => {
            pt.x += cx;
            pt.y += cy;
        });
        const midTop = rotatePoint({ x: 0, y: -hh - 30 }, r.angle);
        return [
            corners[0],
            corners[1],
            corners[2],
            corners[3],
            { x: cx + midTop.x, y: cy + midTop.y }
        ];
    }

    function rotatePoint(pt, angle) {
        const cos = Math.cos(angle), sin = Math.sin(angle);
        return {
            x: pt.x * cos - pt.y * sin,
            y: pt.x * sin + pt.y * cos
        };
    }

    function getBoundingBox(r) {
        const handles = getHandles(r);
        const corners = handles.slice(0, 4);
        let minX = corners[0].x, maxX = corners[0].x;
        let minY = corners[0].y, maxY = corners[0].y;
        for (let i = 1; i < 4; i++) {
            minX = Math.min(minX, corners[i].x);
            maxX = Math.max(maxX, corners[i].x);
            minY = Math.min(minY, corners[i].y);
            maxY = Math.max(maxY, corners[i].y);
        }
        return { minX, minY, maxX, maxY };
    }

    function boundingBoxesOverlap(a, b) {
        return !(a.maxX < b.minX || a.minX > b.maxX || a.maxY < b.minY || a.minY > b.maxY);
    }

    // --- Multiple rectangles support with initial separation ---
    const NUM_RECTS = 3;
    let rects = [];
    const maxTries = 1000;
    for (let i = 0; i < NUM_RECTS; i++) {
        let placed = false, tries = 0;
        while (!placed && tries < maxTries) {
            tries++;
            let w = 180, h = 120;
            let angle = Math.random() * Math.PI * 2;
            let x = Math.random() * (canvas.width - w - 40) + 20;
            let y = Math.random() * (canvas.height - h - 40) + 20;
            let rect = { x, y, w, h, angle };
            let bbox = getBoundingBox(rect);
            let overlap = false;
            for (let j = 0; j < rects.length; j++) {
                let otherBbox = getBoundingBox(rects[j]);
                if (boundingBoxesOverlap(bbox, otherBbox)) {
                    overlap = true;
                    break;
                }
            }
            if (!overlap) {
                rects.push(rect);
                placed = true;
            }
        }
        if (!placed) {
            // fallback: just place without rotation and with more spacing
            let w = 180, h = 120;
            let x = 40 + i * (w + 40);
            let y = 40 + i * (h + 40);
            rects.push({ x, y, w, h, angle: 0 });
        }
    }

    function getHandlesForRect(r) {
        return getHandles(r);
    }

    function drawBoundingBox(r) {
        const bbox = getBoundingBox(r);
        ctx.save();
        ctx.strokeStyle = '#888';
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 1;
        ctx.strokeRect(bbox.minX, bbox.minY, bbox.maxX - bbox.minX, bbox.maxY - bbox.minY);
        ctx.setLineDash([]);
        ctx.restore();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        rects.forEach((rect, idx) => {
            drawBoundingBox(rect);

            ctx.save();
            ctx.translate(rect.x + rect.w / 2, rect.y + rect.h / 2);
            ctx.rotate(rect.angle);
            ctx.strokeStyle = '#0074D9';
            ctx.lineWidth = 2;
            ctx.strokeRect(-rect.w / 2, -rect.h / 2, rect.w, rect.h);
            ctx.restore();

            ctx.fillStyle = '#FF4136';
            ctx.strokeStyle = '#FF4136';
            const handles = getHandlesForRect(rect);
            for (let i = 0; i < 4; i++) {
                const h = handles[i];
                ctx.beginPath();
                ctx.moveTo(h.x - handleSize / 2, h.y);
                ctx.quadraticCurveTo(h.x, h.y - handleSize / 2, h.x + handleSize / 2, h.y);
                ctx.quadraticCurveTo(h.x, h.y + handleSize / 2, h.x - handleSize / 2, h.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            // Draw rotation handle (circle)
            const rot = handles[4];
            ctx.beginPath();
            ctx.arc(rot.x, rot.y, handleSize / 1.5, 0, Math.PI * 2);
            ctx.fillStyle = '#2ECC40';
            ctx.fill();
            ctx.stroke();

            // Draw line from top edge to rotation handle
            ctx.beginPath();
            ctx.moveTo((handles[0].x + handles[1].x) / 2, (handles[0].y + handles[1].y) / 2);
            ctx.lineTo(rot.x, rot.y);
            ctx.strokeStyle = '#2ECC40';
            ctx.stroke();
        });
    }

    function pointInHandle(mx, my, rect) {
        const handles = getHandlesForRect(rect);
        for (let i = 0; i < 4; i++) {
            const h = handles[i];
            if (
                mx >= h.x - handleSize &&
                mx <= h.x + handleSize &&
                my >= h.y - handleSize &&
                my <= h.y + handleSize
            ) {
                return i;
            }
        }
        const r = handles[4];
        const dist = Math.hypot(mx - r.x, my - r.y);
        if (dist <= handleSize * 1.5) return 4;
        return null;
    }

    function pointInRect(mx, my, rect) {
        const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
        const dx = mx - cx, dy = my - cy;
        const cos = Math.cos(-rect.angle), sin = Math.sin(-rect.angle);
        const lx = dx * cos - dy * sin;
        const ly = dx * sin + dy * cos;
        return (
            lx >= -rect.w / 2 && lx <= rect.w / 2 &&
            ly >= -rect.h / 2 && ly <= rect.h / 2
        );
    }

    // --- Prevent collision on drag/resize/rotate ---

    function wouldCollide(testRect, ignoreIdx) {
        const testBox = getBoundingBox(testRect);
        for (let i = 0; i < rects.length; i++) {
            if (i === ignoreIdx) continue;
            const otherBox = getBoundingBox(rects[i]);
            if (boundingBoxesOverlap(testBox, otherBox)) return true;
        }
        return false;
    }

    canvas.addEventListener('mousedown', (e) => {
        const rectCanvas = canvas.getBoundingClientRect();
        const mx = e.clientX - rectCanvas.left;
        const my = e.clientY - rectCanvas.top;

        // Find topmost handle/rotation/rect under mouse
        activeRectIdx = null;
        for (let i = rects.length - 1; i >= 0; i--) {
            const handle = pointInHandle(mx, my, rects[i]);
            if (handle !== null) {
                activeRectIdx = i;
                if (handle === 4) {
                    rotating = true;
                    const rect = rects[activeRectIdx];
                    const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
                    rotateStartAngle = rect.angle;
                    rotateStartMouse = { x: mx - cx, y: my - cy };
                } else {
                    resizing = true;
                    activeHandle = handle;
                }
                break;
            } else if (pointInRect(mx, my, rects[i])) {
                activeRectIdx = i;
                dragging = true;
                const rect = rects[activeRectIdx];
                const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
                const dx = mx - cx, dy = my - cy;
                const cos = Math.cos(-rect.angle), sin = Math.sin(-rect.angle);
                dragOffset.x = dx * cos - dy * sin;
                dragOffset.y = dx * sin + dy * cos;
                break;
            }
        }
        draw();
    });

    // Helper for continuous collision detection (CCD)
    function interpolateAndMoveRect(rect, from, to, updateFn, ignoreIdx) {
        const steps = 20;
        let lastValid = { ...from };
        for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const interp = {};
            for (const key in from) {
                interp[key] = from[key] + (to[key] - from[key]) * t;
            }
            if (!wouldCollide(interp, ignoreIdx)) {
                lastValid = { ...interp };
            } else {
                break;
            }
        }
        updateFn(lastValid);
    }

    canvas.addEventListener('mousemove', (e) => {
        const rectCanvas = canvas.getBoundingClientRect();
        const mx = e.clientX - rectCanvas.left;
        const my = e.clientY - rectCanvas.top;

        if (resizing && activeRectIdx !== null && activeHandle !== null) {
            const rect = rects[activeRectIdx];
            const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
            const cos = Math.cos(-rect.angle), sin = Math.sin(-rect.angle);
            const dx = mx - cx, dy = my - cy;
            const lx = dx * cos - dy * sin;
            const ly = dx * sin + dy * cos;
            let x0 = -rect.w / 2, y0 = -rect.h / 2, x1 = rect.w / 2, y1 = rect.h / 2;
            switch (activeHandle) {
                case 0: x0 = lx; y0 = ly; break;
                case 1: x1 = lx; y0 = ly; break;
                case 2: x0 = lx; y1 = ly; break;
                case 3: x1 = lx; y1 = ly; break;
            }
            let newW = Math.max(x1 - x0, handleSize * 2);
            let newH = Math.max(y1 - y0, handleSize * 2);

            // Simulate new rect for collision check
            const newRect = {
                x: 0, y: 0, w: newW, h: newH, angle: rect.angle
            };
            const newCx = cx + ((x0 + x1) / 2) * Math.cos(rect.angle) - ((y0 + y1) / 2) * Math.sin(rect.angle);
            const newCy = cy + ((x0 + x1) / 2) * Math.sin(rect.angle) + ((y0 + y1) / 2) * Math.cos(rect.angle);
            newRect.x = newCx - newW / 2;
            newRect.y = newCy - newH / 2;

            // Continuous collision detection
            interpolateAndMoveRect(
                rect,
                { x: rect.x, y: rect.y, w: rect.w, h: rect.h, angle: rect.angle },
                { x: newRect.x, y: newRect.y, w: newW, h: newH, angle: rect.angle },
                (lastValid) => {
                    rect.x = lastValid.x;
                    rect.y = lastValid.y;
                    rect.w = lastValid.w;
                    rect.h = lastValid.h;
                },
                activeRectIdx
            );
            draw();
        } else if (dragging && activeRectIdx !== null) {
            const rect = rects[activeRectIdx];
            const cx = mx, cy = my;
            const cos = Math.cos(rect.angle), sin = Math.sin(rect.angle);
            const localX = dragOffset.x, localY = dragOffset.y;
            const dx = localX * cos - localY * sin;
            const dy = localX * sin + localY * cos;
            // Simulate new rect for collision check
            const newRect = {
                x: cx - dx - rect.w / 2,
                y: cy - dy - rect.h / 2,
                w: rect.w,
                h: rect.h,
                angle: rect.angle
            };
            interpolateAndMoveRect(
                rect,
                { x: rect.x, y: rect.y, w: rect.w, h: rect.h, angle: rect.angle },
                { x: newRect.x, y: newRect.y, w: rect.w, h: rect.h, angle: rect.angle },
                (lastValid) => {
                    rect.x = lastValid.x;
                    rect.y = lastValid.y;
                },
                activeRectIdx
            );
            draw();
        } else if (rotating && activeRectIdx !== null) {
            const rect = rects[activeRectIdx];
            const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
            const angle1 = Math.atan2(rotateStartMouse.y, rotateStartMouse.x);
            const angle2 = Math.atan2(my - cy, mx - cx);
            const newAngle = rotateStartAngle + (angle2 - angle1);
            // Simulate new rect for collision check
            interpolateAndMoveRect(
                rect,
                { x: rect.x, y: rect.y, w: rect.w, h: rect.h, angle: rect.angle },
                { x: rect.x, y: rect.y, w: rect.w, h: rect.h, angle: newAngle },
                (lastValid) => {
                    rect.angle = lastValid.angle;
                },
                activeRectIdx
            );
            draw();
        } else {
            // Show pointer for any handle/rotation/rect
            let found = false;
            for (let i = rects.length - 1; i >= 0; i--) {
                const handle = pointInHandle(mx, my, rects[i]);
                if (handle !== null) {
                    if (handle === 4) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'pointer';
                    }
                    found = true;
                    break;
                } else if (pointInRect(mx, my, rects[i])) {
                    canvas.style.cursor = 'move';
                    found = true;
                    break;
                }
            }
            if (!found) {
                canvas.style.cursor = 'default';
            }
        }
    });

    canvas.addEventListener('mouseup', () => {
        dragging = false;
        resizing = false;
        rotating = false;
        activeHandle = null;
        activeRectIdx = null;
    });

    canvas.addEventListener('mouseleave', () => {
        dragging = false;
        resizing = false;
        rotating = false;
        activeHandle = null;
        activeRectIdx = null;
    });

    draw();
    </script>
</body>
</html>