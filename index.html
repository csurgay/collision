<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collision</title>
</head>
<body>
    <canvas id="collision" width="800" height="600" style="border:1px solid #000;"></canvas>
    <script>
    const canvas = document.getElementById('collision');
    const ctx = canvas.getContext('2d');
    const handleSize = 10;
    let dragging = false;
    let dragOffset = { x: 0, y: 0 };
    let resizing = false;
    let activeHandle = null;
    let rotating = false;
    let rotateStartAngle = 0;
    let rotateStartMouse = { x: 0, y: 0 };
    let activeRectIdx = null;

    function getHandles(r) {
        const hw = r.w / 2, hh = r.h / 2;
        const cx = r.x + hw, cy = r.y + hh;
        const corners = [
            { x: -hw, y: -hh },
            { x: hw, y: -hh },
            { x: -hw, y: hh },
            { x: hw, y: hh }
        ].map(pt => rotatePoint(pt, r.angle));
        corners.forEach(pt => {
            pt.x += cx;
            pt.y += cy;
        });
        const midTop = rotatePoint({ x: 0, y: -hh - 30 }, r.angle);
        return [
            corners[0],
            corners[1],
            corners[2],
            corners[3],
            { x: cx + midTop.x, y: cy + midTop.y }
        ];
    }

    function rotatePoint(pt, angle) {
        const cos = Math.cos(angle), sin = Math.sin(angle);
        return {
            x: pt.x * cos - pt.y * sin,
            y: pt.x * sin + pt.y * cos
        };
    }

    // --- Multiple rectangles support ---
    const NUM_RECTS = 3;
    let rects = [];
    for (let i = 0; i < NUM_RECTS; i++) {
        rects.push({
            x: 150 + i * 120,
            y: 120 + i * 80,
            w: 180,
            h: 120,
            angle: Math.random() * Math.PI * 2
        });
    }

    function getHandlesForRect(r) {
        return getHandles(r);
    }

    function drawBoundingBox(r) {
        const handles = getHandlesForRect(r);
        const corners = handles.slice(0, 4);
        let minX = corners[0].x, maxX = corners[0].x;
        let minY = corners[0].y, maxY = corners[0].y;
        for (let i = 1; i < 4; i++) {
            minX = Math.min(minX, corners[i].x);
            maxX = Math.max(maxX, corners[i].x);
            minY = Math.min(minY, corners[i].y);
            maxY = Math.max(maxY, corners[i].y);
        }
        ctx.save();
        ctx.strokeStyle = '#888';
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = 1;
        ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
        ctx.setLineDash([]);
        ctx.restore();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        rects.forEach((rect, idx) => {
            drawBoundingBox(rect);

            ctx.save();
            ctx.translate(rect.x + rect.w / 2, rect.y + rect.h / 2);
            ctx.rotate(rect.angle);
            ctx.strokeStyle = '#0074D9';
            ctx.lineWidth = 2;
            ctx.strokeRect(-rect.w / 2, -rect.h / 2, rect.w, rect.h);
            ctx.restore();

            ctx.fillStyle = '#FF4136';
            ctx.strokeStyle = '#FF4136';
            const handles = getHandlesForRect(rect);
            for (let i = 0; i < 4; i++) {
                const h = handles[i];
                ctx.beginPath();
                ctx.moveTo(h.x - handleSize / 2, h.y);
                ctx.quadraticCurveTo(h.x, h.y - handleSize / 2, h.x + handleSize / 2, h.y);
                ctx.quadraticCurveTo(h.x, h.y + handleSize / 2, h.x - handleSize / 2, h.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            // Draw rotation handle (circle)
            const rot = handles[4];
            ctx.beginPath();
            ctx.arc(rot.x, rot.y, handleSize / 1.5, 0, Math.PI * 2);
            ctx.fillStyle = '#2ECC40';
            ctx.fill();
            ctx.stroke();

            // Draw line from top edge to rotation handle
            ctx.beginPath();
            ctx.moveTo((handles[0].x + handles[1].x) / 2, (handles[0].y + handles[1].y) / 2);
            ctx.lineTo(rot.x, rot.y);
            ctx.strokeStyle = '#2ECC40';
            ctx.stroke();
        });
    }

    function pointInHandle(mx, my, rect) {
        const handles = getHandlesForRect(rect);
        for (let i = 0; i < 4; i++) {
            const h = handles[i];
            if (
                mx >= h.x - handleSize &&
                mx <= h.x + handleSize &&
                my >= h.y - handleSize &&
                my <= h.y + handleSize
            ) {
                return i;
            }
        }
        const r = handles[4];
        const dist = Math.hypot(mx - r.x, my - r.y);
        if (dist <= handleSize * 1.5) return 4;
        return null;
    }

    function pointInRect(mx, my, rect) {
        const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
        const dx = mx - cx, dy = my - cy;
        const cos = Math.cos(-rect.angle), sin = Math.sin(-rect.angle);
        const lx = dx * cos - dy * sin;
        const ly = dx * sin + dy * cos;
        return (
            lx >= -rect.w / 2 && lx <= rect.w / 2 &&
            ly >= -rect.h / 2 && ly <= rect.h / 2
        );
    }

    canvas.addEventListener('mousedown', (e) => {
        const rectCanvas = canvas.getBoundingClientRect();
        const mx = e.clientX - rectCanvas.left;
        const my = e.clientY - rectCanvas.top;

        // Find topmost handle/rotation/rect under mouse
        activeRectIdx = null;
        for (let i = rects.length - 1; i >= 0; i--) {
            const handle = pointInHandle(mx, my, rects[i]);
            if (handle !== null) {
                activeRectIdx = i;
                if (handle === 4) {
                    rotating = true;
                    const rect = rects[activeRectIdx];
                    const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
                    rotateStartAngle = rect.angle;
                    rotateStartMouse = { x: mx - cx, y: my - cy };
                } else {
                    resizing = true;
                    activeHandle = handle;
                }
                break;
            } else if (pointInRect(mx, my, rects[i])) {
                activeRectIdx = i;
                dragging = true;
                const rect = rects[activeRectIdx];
                const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
                const dx = mx - cx, dy = my - cy;
                const cos = Math.cos(-rect.angle), sin = Math.sin(-rect.angle);
                dragOffset.x = dx * cos - dy * sin;
                dragOffset.y = dx * sin + dy * cos;
                break;
            }
        }
        draw();
    });

    canvas.addEventListener('mousemove', (e) => {
        const rectCanvas = canvas.getBoundingClientRect();
        const mx = e.clientX - rectCanvas.left;
        const my = e.clientY - rectCanvas.top;

        if (resizing && activeRectIdx !== null && activeHandle !== null) {
            const rect = rects[activeRectIdx];
            const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
            const cos = Math.cos(-rect.angle), sin = Math.sin(-rect.angle);
            const dx = mx - cx, dy = my - cy;
            const lx = dx * cos - dy * sin;
            const ly = dx * sin + dy * cos;
            let x0 = -rect.w / 2, y0 = -rect.h / 2, x1 = rect.w / 2, y1 = rect.h / 2;
            switch (activeHandle) {
                case 0: x0 = lx; y0 = ly; break;
                case 1: x1 = lx; y0 = ly; break;
                case 2: x0 = lx; y1 = ly; break;
                case 3: x1 = lx; y1 = ly; break;
            }
            let newW = Math.max(x1 - x0, handleSize * 2);
            let newH = Math.max(y1 - y0, handleSize * 2);
            rect.w = newW;
            rect.h = newH;
            const newCx = cx + ((x0 + x1) / 2) * Math.cos(rect.angle) - ((y0 + y1) / 2) * Math.sin(rect.angle);
            const newCy = cy + ((x0 + x1) / 2) * Math.sin(rect.angle) + ((y0 + y1) / 2) * Math.cos(rect.angle);
            rect.x = newCx - rect.w / 2;
            rect.y = newCy - rect.h / 2;
            draw();
        } else if (dragging && activeRectIdx !== null) {
            const rect = rects[activeRectIdx];
            const cx = mx, cy = my;
            const cos = Math.cos(rect.angle), sin = Math.sin(rect.angle);
            const localX = dragOffset.x, localY = dragOffset.y;
            const dx = localX * cos - localY * sin;
            const dy = localX * sin + localY * cos;
            rect.x = cx - dx - rect.w / 2;
            rect.y = cy - dy - rect.h / 2;
            draw();
        } else if (rotating && activeRectIdx !== null) {
            const rect = rects[activeRectIdx];
            const cx = rect.x + rect.w / 2, cy = rect.y + rect.h / 2;
            const angle1 = Math.atan2(rotateStartMouse.y, rotateStartMouse.x);
            const angle2 = Math.atan2(my - cy, mx - cx);
            rect.angle = rotateStartAngle + (angle2 - angle1);
            draw();
        } else {
            // Show pointer for any handle/rotation/rect
            let found = false;
            for (let i = rects.length - 1; i >= 0; i--) {
                const handle = pointInHandle(mx, my, rects[i]);
                if (handle !== null) {
                    if (handle === 4) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'pointer';
                    }
                    found = true;
                    break;
                } else if (pointInRect(mx, my, rects[i])) {
                    canvas.style.cursor = 'move';
                    found = true;
                    break;
                }
            }
            if (!found) {
                canvas.style.cursor = 'default';
            }
        }
    });

    canvas.addEventListener('mouseup', () => {
        dragging = false;
        resizing = false;
        rotating = false;
        activeHandle = null;
        activeRectIdx = null;
    });

    canvas.addEventListener('mouseleave', () => {
        dragging = false;
        resizing = false;
        rotating = false;
        activeHandle = null;
        activeRectIdx = null;
    });

    draw();
    </script>
</body>
</html>